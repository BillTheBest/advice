<!DOCTYPE html>

<html>
<head>
  <title>Advice</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
    <ul class="sections">
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              <h1 id="advice">Advice</h1>
<p>Based on the Advice functional mixin library by Angus Croll. Adds functional mixins to an object.
Advice offers a number of ways to modify methods and properties on an object.  It makes it possible to reuse code and compose together functionality to create an object behavior.</p>
<h2 id="usage">Usage</h2>
<p>You can add advice to any object. A simple example might be adding logging functionality to your views in an application.</p>
<pre><code class="lang-javascript">Advice.addAdvice(MyApp.View);
</code></pre>
<p>where MyApp.View is the view constructor in your framework.</p>
<p>Lets say MyApp.View has a clickHandler method that is called when it is clicked . You can then do the following using advice:</p>
<pre><code class="lang-javascript">MyApp.View.after({
clickHandler: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>, <span class="hljs-string">' was clicked'</span>);
}
})
</code></pre>
<p>Now any time an instance of MyApp.View is clicked it will log the event to the console. This is very useful for situations where you want to reuse a piece of common functionality across objects. </p>
<p>Lets try doing the same thing with a <strong>“mixin”</strong> which is essentially a function that is called in the scope of the target object.  Since the target object already has the advice methods added to it, one just has to call the desired advice in the <em>this</em> context.</p>
<p>Here’s a list of the available methods that are added onto an object using <strong>.addAdvice(targetObject)</strong>:</p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Behavior</th>
</tr>
</thead>
<tbody>
<tr>
<td>before</td>
<td>Adds on the supplied method to be called before the original method(s) run</td>
</tr>
<tr>
<td>after</td>
<td>Adds on the supplied method to be called after the original method(s) have run</td>
</tr>
<tr>
<td>clobber</td>
<td>Overwrites the original properties of an object</td>
</tr>
<tr>
<td>around</td>
<td>Adds on the supplied method instead of the super method, but passes a reference to the original method as the first argument followed by the arguments the method was called with</td>
</tr>
<tr>
<td>addToObj</td>
<td>Extends the keys of an object with the keys of the provided object</td>
</tr>
<tr>
<td>setDefaults</td>
<td>Adds properties (methods, objects, etc) to the constructor if they don’t already exist</td>
</tr>
<tr>
<td>mixin</td>
<td>Pass an array of mixins that should be mixed in to the target object</td>
</tr>
</tbody>
</table>
<pre><code class="lang-javascript"><span class="hljs-comment">// Add advice to the views in our framework</span>
Advice.addAdvice(MyApp.View);

<span class="hljs-comment">// Define our logging mixin</span>
<span class="hljs-keyword">var</span> loggingMixin = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(options)</span> </span>{
<span class="hljs-keyword">this</span>.after({
initialize: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
logger.log(<span class="hljs-string">'Initialized '</span> + <span class="hljs-keyword">this</span>.name) <span class="hljs-comment">// Log initialized view</span>
}
})
};
<span class="hljs-keyword">var</span> myViewClass1 = MyApp.View.extend({
name: <span class="hljs-string">'view1'</span>
});
<span class="hljs-keyword">var</span> myViewClass2 = MyApp.View.extend({
name: <span class="hljs-string">'view2'</span>
});
<span class="hljs-comment">// Apply the mixin to the desired views</span>
myViewClass1.mixin(loggingMixin); <span class="hljs-comment">// Add logging to myViewClass1</span>

<span class="hljs-comment">// Instantiate the views</span>
<span class="hljs-keyword">var</span> view1 = <span class="hljs-keyword">new</span> myViewClass1(); <span class="hljs-comment">// Logs "Initialized view1"</span>
<span class="hljs-keyword">var</span> view2 = <span class="hljs-keyword">new</span> myViewClass2(); <span class="hljs-comment">// Doesn't log anything</span>
</code></pre>
<p>Lets take a more complex example using the Backbone framework.</p>
<pre><code class="lang-javascript"><span class="hljs-comment">// add the mixin capability (may already be done for you)</span>
Advice.addAdvice(Backbone.View)

<span class="hljs-comment">// define a mixin</span>
<span class="hljs-keyword">var</span> namer = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(options)</span> </span>{
<span class="hljs-comment">// options an object that may be passed in</span>

<span class="hljs-comment">// any functions under clobber will be replaced</span>
<span class="hljs-keyword">this</span>.clobber({
initialize: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
<span class="hljs-keyword">this</span>.spoke = options.times || <span class="hljs-number">0</span>;
}
});

<span class="hljs-comment">// these will only be set if there is no existing function</span>
<span class="hljs-keyword">this</span>.setDefaults({
name: <span class="hljs-string">'frank'</span>,
getName: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name;
},
speak: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'hello '</span> + <span class="hljs-keyword">this</span>.getName());
}
});

<span class="hljs-comment">// first argument will be the original function - can also take an object of functions</span>
<span class="hljs-keyword">this</span>.around(<span class="hljs-string">'getName'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(orig)</span> </span>{
<span class="hljs-keyword">return</span> orig().split(<span class="hljs-string">' '</span>)[<span class="hljs-number">0</span>];
});

<span class="hljs-comment">// can even extend objects - useful for adding events</span>
<span class="hljs-keyword">this</span>.addToObj({
events: {
<span class="hljs-string">'greeted'</span> :<span class="hljs-string">'speak'</span>
}
});

<span class="hljs-comment">// first argument will be the original function - can also take an object of functions</span>
<span class="hljs-keyword">this</span>.before(<span class="hljs-string">'speak'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
<span class="hljs-keyword">this</span>.spoke++;
});

<span class="hljs-comment">// first argument will be the original function - can also take an object of functions</span>
<span class="hljs-keyword">this</span>.after(<span class="hljs-string">'speak'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'for the '</span> + <span class="hljs-keyword">this</span>.spoke + <span class="hljs-string">'th time'</span>);
});

}


<span class="hljs-keyword">var</span> Speaker = Backbone.View.extend({
name: <span class="hljs-string">'Bob White'</span> <span class="hljs-comment">// the set defaults won't override this</span>
}).mixin([
namer
], { <span class="hljs-comment">// options passed in</span>
times: <span class="hljs-number">3</span>
});

<span class="hljs-keyword">var</span> bob = <span class="hljs-keyword">new</span> Speaker();
bob.speak();  <span class="hljs-comment">// Hello Bob</span>
<span class="hljs-comment">// for the 4th time</span>
</code></pre>
<p>You can even call addToObj, clobber, setDefaults, after, before and around straight on the constructor rather than creating the mixin function:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> ShoutName = Speaker.extend().around(<span class="hljs-string">'getName'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(orig)</span> </span>{
<span class="hljs-keyword">return</span> orig().toUpperCase();
});
</code></pre>
<p>We can also setup a sort of pseudo inheritance between mixins, say we wanted the previous example to work on it’s own we could do this:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> shouter = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(options)</span> </span>{

<span class="hljs-comment">// pull in any other mixins this one depends on</span>
<span class="hljs-keyword">this</span>.mixin([
namer
], options);

<span class="hljs-comment">// now we can decorate</span>
<span class="hljs-keyword">this</span>.around(<span class="hljs-string">'getName'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(orig)</span> </span>{
<span class="hljs-keyword">return</span> orig().toUpperCase();
});
}

<span class="hljs-keyword">var</span> ShoutName = Backbone.View.extend().mixin([
shouter
]);
</code></pre>
<p>Mixins will keep a record of what has been put on, so a mixin will only be applied once (this may cause issues if you’d like to re-apply a mixin with a different set of options).</p>
<p>notice that we’re extending before the mixin to get the right prototype chain before mixing in.</p>
<p>Mixins can also be objects like this:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> myMixin = {
clobber: {
clobbered: <span class="hljs-literal">true</span>;
},
addToObj: {
events: {
<span class="hljs-string">'click'</span>: <span class="hljs-string">'onClick'</span>
}
},
after: {
<span class="hljs-string">'render'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'rendering done'</span>);
}
}
};
</code></pre>
<p>Be careful though, only mixins that were defined as functions are able to see if they have been applied before. To fix this you can return the object from a function:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> myMixinFn = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
<span class="hljs-keyword">return</span> myMixin;
}
</code></pre>
<p>or even use the return method to pass in the options object:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> myMixinFn = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(options)</span> </span>{
<span class="hljs-keyword">return</span> {
setDefaults: {
number: options.number
}
};
}
</code></pre>

            </div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
